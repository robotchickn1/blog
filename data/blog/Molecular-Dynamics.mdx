---
title: My Molecular Dynamics Report
date: '2025-03-17'
tags: [Molecular Dynamics, Scilab, Computation]
draft: false
summary: Running a simulation of a gaseous system of 0.1 million atoms using Scilab and VMD.
---

<h2 id="aim">Aim</h2>
<ul>
<li>Write an algorithm to carry out a simulation of a simple gaseous system using Scilab and VMD.</li>
</ul>
<h2 id="software">Software</h2>
<ul>
<li><a href="https://www.scilab.org/">Scilab</a> - for writing the algorithms to create a gaseous system</li>
<li><a href="https://www.ks.uiuc.edu/Research/vmd/">VMD (Visual Molecular Dynamics)</a> - for visualization of a simulated gaseous system</li>
<li><a href="https://plasma-gate.weizmann.ac.il/Grace/">xmgrace</a> - for plotting data</li>
</ul>
<h2 id="theory">Theory</h2>
<h3 id="molecular-dynamics">Molecular Dynamics</h3>
<ul>
<li>Molecular dynamics (MD) is a computer simulation method for analyzing the physical movements of atoms and molecules, obtained by numerically solving Newton&#39;s equations of motion for a system of interacting particles.</li>
<li>In MD, the nuclear motion of the constituent particles is assumed to obey the laws of classical mechanics only. This is a very good approximation for a wide range of materials. Quantum effects start when we consider the translational or rotational motion of light atoms or molecules (He, H2, D2) or vibrational motion with a frequency such that
$$
h\nu\;&gt;\;k_{B}T
$$</li>
</ul>
<h3 id="periodic-boundary-conditions">Periodic Boundary Conditions</h3>
<p>Periodic Boundary Conditions (PBCs) simulate an <em>infinite system</em> by wrapping particles that exit one side of the simulation box back into the opposite side. This eliminates edge effects and mimics bulk behavior in finite systems.</p>
<p>When a particle crosses a boundary:</p>
<p>$$
x_i \rightarrow x<em>i - L.round(\frac{x</em>{i}}{L})
$$</p>
<p>where $L$ is the length of the simulation box.</p>
<h3 id="minimum-image-convention">Minimum Image Convention</h3>
<p>The Minimum Image Convention ensures that <em>each particle interacts only with the closest periodic image of other particles</em>.<br>For a cubic box with length $L$, the displacement vector between particles $i$ and $j$ is adjusted as:</p>
<p>$$
r_{ij} = r_i - r_j
$$</p>
<p>$$
r<em>{ij} = r</em>{ij} - L \times \text{round} \left( \frac{r_{ij}}{L} \right)
$$</p>
<h3 id="potentials">Potentials</h3>
<ul>
<li>Molecular systems at atomic resolution are described in terms of <em>intramolecular</em> interactions and <em>intermolecular</em> interactions.</li>
<li>The &#39;intra&#39; constitutes all bonded interactions and the &#39;inter&#39; constitutes the non-bonded interactions.</li>
<li><strong>Bonded Interactions</strong><ul>
<li>Bonds</li>
<li>Angles</li>
<li>Dihedrals</li>
</ul>
</li>
<li><strong>Non-bonded Interactions</strong><ul>
<li>Van der Waals interaction</li>
<li>Electrostatic interactions</li>
</ul>
</li>
</ul>
<h3 id="lennard-jones-potential">Lennard-Jones Potential</h3>
<p>The Lennard-Jones potential is a simple model that describes the essential features of interactions between simple atoms and molecules: Two interacting particles repel each other at very close distance, attract each other at moderate distance, and eventually stop interacting at infinite distance.</p>
<p>The above image is a graph of the Lennard-Jones potential function. The general potential is given as:</p>
<p>$$
V<em>{LJ}(r) = \frac{A</em>{n}}{r^{n}} - \frac{B_{m}}{r^{m}}
$$</p>
<p>The most common form of this potential is the Lennard-Jones 12-6 potential:</p>
<p>$$
V_{LJ}(r) = 4\epsilon\;[(\frac{\sigma}{r^{12}} - \frac{\sigma}{r^{6}})]
$$</p>
<p>where, the 1st term represents the repulsion term of potential (hence, positive) and the 2nd term represents the attractive term (hence, negative).</p>
<h3 id="ergodic-hypothesis">Ergodic Hypothesis</h3>
<p>The ergodic hypothesis states that, over long periods of time, the time average of a system&#39;s observable property is equal to the ensemble average of that property. In simpler terms, it suggests that the time a system spends in a particular state is proportional to the number of microstates corresponding to that state.</p>
<hr>
<h2 id="algorithm">Algorithm</h2>
<ul>
<li><strong>Initialization</strong><ul>
<li>positions and velocities of $N$ particles are randomly initiated inside a cubic box of length $L$.</li>
</ul>
</li>
<li><strong>Force Calculation</strong><ul>
<li>Calculate forces between particles using the Minimum Image Convention.</li>
</ul>
</li>
<li><strong>Integrate equations of motion</strong><ul>
<li>Integrate Newtonâ€™s equations of motion using the <em>Velocity-Verlet algorithm</em>.</li>
</ul>
</li>
<li><strong>MD Simulation</strong><ul>
<li>Iterate over time steps, updating positions and velocities.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="scilab-code">Scilab Code</h2>
<h3 id="subroutine-lattice-positions">Subroutine: Lattice Positions</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[a1, a2, a3]</span> = <span class="hljs-title">lattice_pos</span><span class="hljs-params">(index, Lx, Ly, Lz, lattice_const)</span></span>
    l = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = -Lx/<span class="hljs-number">2</span>:Lx/<span class="hljs-number">2</span>
        x = <span class="hljs-built_in">i</span> * lattice_const;
        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = -Ly/<span class="hljs-number">2</span>:Ly/<span class="hljs-number">2</span>
            y = <span class="hljs-built_in">j</span> * lattice_const;
            <span class="hljs-keyword">for</span> k = -Lz/<span class="hljs-number">2</span>:Lz/<span class="hljs-number">2</span>
                z = k * lattice_const;
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(x) &lt; Lx/<span class="hljs-number">2</span>) &amp; (<span class="hljs-built_in">abs</span>(y) &lt; Ly/<span class="hljs-number">2</span>) &amp; (<span class="hljs-built_in">abs</span>(z) &lt; Lz/<span class="hljs-number">2</span>) &amp; (l &lt;= index) then
                    a1 = x;
                    a2 = y;
                    a3 = z;
                    l = l + <span class="hljs-number">1</span>;
                <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
endfunction
</code></pre><ul>
<li>Here, we create a function called <code>lattice_pos</code>. This function takes inputs: <code>index</code>, <code>Lx</code>, <code>Ly</code>, <code>Lz</code> and <code>lattice_const</code> and gives outputs: <code>a1</code>, <code>a2</code> and <code>a3</code>.</li>
<li>This function essentially generates the lattice coordinates of <code>npart</code> no. of particles.</li>
<li>It starts by placing an atom at ${-L}/{2}$ to $L/2$ in x, y and z directions.</li>
<li><code>Lx</code>, <code>Ly</code> and <code>Lz</code> are the dimensions of the system box.</li>
</ul>
<h3 id="subroutine-initialization">Subroutine: Initialization</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[x, y, z, xm, ym, zm, vx, vy, vz]</span> = <span class="hljs-title">initialization</span><span class="hljs-params">(npart, dt, Lx, Ly, Lz, lattice_const, temp)</span></span>

    sumvx = <span class="hljs-number">0</span>;
    sumvy = <span class="hljs-number">0</span>;
    sumvz = <span class="hljs-number">0</span>;
    sumv2 = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:npart
        [x(i), y(i), z(i)] = lattice_pos(<span class="hljs-built_in">i</span>, Lx, Ly, Lz, lattice_const);

        vx(<span class="hljs-built_in">i</span>) = (<span class="hljs-built_in">rand</span>() - <span class="hljs-number">0.5</span>);
        vy(<span class="hljs-built_in">i</span>) = (<span class="hljs-built_in">rand</span>() - <span class="hljs-number">0.5</span>);
        vz(<span class="hljs-built_in">i</span>) = (<span class="hljs-built_in">rand</span>() - <span class="hljs-number">0.5</span>);

        sumvx = sumvx + vx(<span class="hljs-built_in">i</span>);
        sumvy = sumvy + vy(<span class="hljs-built_in">i</span>);
        sumvz = sumvz + vz(<span class="hljs-built_in">i</span>);

        sumv2 = sumv2 + (vx(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> + vy(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> + vz(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span>);
    <span class="hljs-keyword">end</span>

    sumvx = sumvx/npart;
    sumvy = sumvy/npart;
    sumvz = sumvz/npart;

    sumv2 = sumv2/npart;

    fs = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">3</span>*temp/sumv2);

    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:npart
        vx(<span class="hljs-built_in">i</span>) = (vx(<span class="hljs-built_in">i</span>) - sumvx) * fs;
        vy(<span class="hljs-built_in">i</span>) = (vy(<span class="hljs-built_in">i</span>) - sumvy) * fs;
        vz(<span class="hljs-built_in">i</span>) = (vz(<span class="hljs-built_in">i</span>) - sumvz) * fs;

        xm(<span class="hljs-built_in">i</span>) = x(<span class="hljs-built_in">i</span>) - vx(<span class="hljs-built_in">i</span>) * dt;
        ym(<span class="hljs-built_in">i</span>) = y(<span class="hljs-built_in">i</span>) - vy(<span class="hljs-built_in">i</span>) * dt;
        zm(<span class="hljs-built_in">i</span>) = z(<span class="hljs-built_in">i</span>) - vz(<span class="hljs-built_in">i</span>) * dt;
    <span class="hljs-keyword">end</span>

endfunction

</code></pre><ul>
<li>Here, we create a function called <code>initialization</code>. The outputs of this function are the positions: <code>x</code>, <code>y</code> and <code>z</code>; the modified positions: <code>xm</code>, <code>ym</code> and <code>zm</code> and the velocities: <code>vx</code>, <code>vy</code> and <code>vz</code>.</li>
<li>The first <code>for loop</code> generates initial positions for 1 to <code>npart</code> no. of particles. After this, the loop gives these particles some random initial velocities in 3D. $-\;0.5$ is subtracted from the <code>rand()</code> function to make the velocity bi-directional (meaning, left and right or north and south).</li>
</ul>
<h4 id="scaling-factor">Scaling Factor</h4>
<ul>
<li>The total velocities and the sum of the squared velocities are added to be used for <strong>average potential energy</strong> and <strong>average kinetic energy</strong> calculations respectively.</li>
<li>Average velocity of the system i.e. <code>sumv/npart</code> and average <code>sumv2</code> are also obtained.</li>
<li>The second <code>for loop</code> modifies the velocities and positions (<code>xm</code>, <code>ym</code> and <code>zm</code>) using an <code>fs</code> - scaling factor.</li>
<li>The <code>scaling factor</code> adjusts velocities so the average kinetic energy corresponds to the desired temp (the <code>3 * temp</code> part comes from <strong>Equipartition theorem</strong>).
$$
From\;Equipartition\;theorem,\;average\;kinetic\;energy = \frac{3}{2} k_{B}  T
$$</li>
<li>Modifies positions are created to store the previous positions values to be used later in the <strong>velocity-verlet calculation</strong>.</li>
</ul>
<h3 id="subroutine-force-calculation">Subroutine: Force Calculation</h3>
<pre><code>function [fx, fy, fz, en] = force(npart, x, y, z, rc, Lx, Ly, Lz, ecut)
    <span class="hljs-attr">en</span> = <span class="hljs-number">0</span>;
    <span class="hljs-attr">fx</span> = zeros(<span class="hljs-number">1</span>, npart);
    <span class="hljs-attr">fy</span> = zeros(<span class="hljs-number">1</span>, npart);
    <span class="hljs-attr">fz</span> = zeros(<span class="hljs-number">1</span>, npart);

    for <span class="hljs-attr">i</span> = <span class="hljs-number">1</span>:npart-<span class="hljs-number">1</span>
        for <span class="hljs-attr">j</span> = i+<span class="hljs-number">1</span>:npart
            <span class="hljs-attr">xr</span> = x(i) - x(j);
            <span class="hljs-attr">xr</span> = xr - Lx*round(xr/Lx);

            <span class="hljs-attr">yr</span> = y(i) - y(j);
            <span class="hljs-attr">yr</span> = yr - Ly*round(yr/Ly);

            <span class="hljs-attr">zr</span> = z(i) - z(j);
            <span class="hljs-attr">zr</span> = zr - Lz*round(zr/Lz);

            <span class="hljs-attr">r2</span> = xr^<span class="hljs-number">2</span> + yr^<span class="hljs-number">2</span> + zr^<span class="hljs-number">2</span>;

            <span class="hljs-attr">rc2</span> = rc^<span class="hljs-number">2</span>;

            <span class="hljs-keyword">if</span> (r2 &lt;= rc2) <span class="hljs-keyword">then</span>
                <span class="hljs-attr">r2i</span> = <span class="hljs-number">1</span>/r2;
                <span class="hljs-attr">r6i</span> = r2i^<span class="hljs-number">3</span>;

                <span class="hljs-attr">ff</span> = <span class="hljs-number">48</span>*r2i*r6i*(r6i-<span class="hljs-number">0.5</span>); //Lennard-Jones Potential

                fx(i) = fx(i) + ff*xr;
                fy(i) = fy(i) + ff*yr;
                fz(i) = fz(i) + ff*zr;

                fx(j) = fx(j) - ff*xr;
                fy(j) = fy(j) - ff*yr;
                fz(j) = fz(j) - ff*zr;

                <span class="hljs-attr">en</span> = en + <span class="hljs-number">4</span>*r6i*(r6i-<span class="hljs-number">1</span>) - ecut;
            end
        end
    end

endfunction

</code></pre><ul>
<li>Here, we introduce a new subroutine called <code>force</code>. This function gives the outputs: force and energy i.e. <code>f</code> and <code>en</code>.</li>
<li>The <code>for loop</code> calculates the forces and the potential energy of the system. It does this by calculating the squared distance <code>r2</code>.</li>
<li>It also computes the inverse distances and force from the Lennard-Jones potential.</li>
</ul>
<h3 id="subroutine-integrate-equations-of-motion">Subroutine: Integrate equations of motion</h3>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[temperature, etot, xm, ym, zm, x, y, z, KE, PE]</span> = <span class="hljs-title">integrate_eqn</span><span class="hljs-params">(npart, Lx, Ly, Lz, dt, x, y, z, xm, ym, zm, fx, fy, fz, en, temp)</span></span>
    sumvv2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:npart
        xx = <span class="hljs-number">2</span>*x(<span class="hljs-built_in">i</span>) - xm(<span class="hljs-built_in">i</span>) + (dt^<span class="hljs-number">2</span>)*fx(<span class="hljs-built_in">i</span>);                    \\verlet algorithm
        yy = <span class="hljs-number">2</span>*y(<span class="hljs-built_in">i</span>) - ym(<span class="hljs-built_in">i</span>) + (dt^<span class="hljs-number">2</span>)*fy(<span class="hljs-built_in">i</span>);
        zz = <span class="hljs-number">2</span>*z(<span class="hljs-built_in">i</span>) - zm(<span class="hljs-built_in">i</span>) + (dt^<span class="hljs-number">2</span>)*fz(<span class="hljs-built_in">i</span>);

        vxx(<span class="hljs-built_in">i</span>) = (xx - xm(<span class="hljs-built_in">i</span>))/(<span class="hljs-number">2</span>*dt);                          \\velocity
        vyy(<span class="hljs-built_in">i</span>) = (yy - ym(<span class="hljs-built_in">i</span>))/(<span class="hljs-number">2</span>*dt);
        vzz(<span class="hljs-built_in">i</span>) = (zz - zm(<span class="hljs-built_in">i</span>))/(<span class="hljs-number">2</span>*dt);

        sumvv2 = sumvv2 + (vxx(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> + vyy(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> + vzz(<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span>);

        xm(<span class="hljs-built_in">i</span>) = x(<span class="hljs-built_in">i</span>);
        x(<span class="hljs-built_in">i</span>) = xx;

        ym(<span class="hljs-built_in">i</span>) = y(<span class="hljs-built_in">i</span>);
        y(<span class="hljs-built_in">i</span>) = yy;

        zm(<span class="hljs-built_in">i</span>) = z(<span class="hljs-built_in">i</span>);
        z(<span class="hljs-built_in">i</span>) = zz;
    <span class="hljs-keyword">end</span>
    temperature = sumvv2/(<span class="hljs-number">3</span>*npart);
    KE = sumvv2/(<span class="hljs-number">2</span>*npart);
    PE = en/npart;
    etot = KE + PE;

endfunction

</code></pre><ul>
<li><code>integrate_eqn</code> gives total energy, positions and modified positions, kinetic and potential energy as the output.</li>
<li>Updates particle positions using Verlet integration and calculates particle velocities (approximate, from positions).</li>
</ul>
<h3 id="subroutine-main-loop">Subroutine: Main loop</h3>
<pre><code><span class="hljs-attr">npart</span> = <span class="hljs-number">100</span>;
<span class="hljs-attr">Lx</span> = <span class="hljs-number">10</span>;
<span class="hljs-attr">Ly</span> = <span class="hljs-number">10</span>;
<span class="hljs-attr">Lz</span> = <span class="hljs-number">10</span>;
<span class="hljs-attr">lattice_const</span> = <span class="hljs-number">1.1</span>;
<span class="hljs-attr">rc</span> = <span class="hljs-number">2.5</span>;
<span class="hljs-attr">ecut</span> = <span class="hljs-number">4</span>*((<span class="hljs-number">1</span>/rc)^<span class="hljs-number">12</span> - (<span class="hljs-number">1</span>/rc)^<span class="hljs-number">6</span>);
<span class="hljs-attr">dt</span> = <span class="hljs-number">0.001</span>;
<span class="hljs-attr">temp</span> = <span class="hljs-number">2</span>;
<span class="hljs-attr">tmax</span> = <span class="hljs-number">100</span>;

<span class="hljs-attr">fd</span> = mopen(<span class="hljs-string">"traj_100.xyz"</span>, <span class="hljs-string">
  "wt"
</span>
);

// Open energy log file <span class="hljs-literal">and</span> add headers

<span class="hljs-attr">energy_file</span> = mopen(<span class="hljs-string">"energy_log.txt"</span>, <span class="hljs-string">
  "wt"
</span>
); mfprintf(energy_file, <span class="hljs-string">
  "Timestep\tKineticEnergy\tPotentialEnergy\tTotalEnergy\n"
</span>);

// Initialization
[x, y, z, xm, ym, zm, vx, vy, vz] = initialization(npart, dt, Lx, Ly, Lz, lattice_const, temp);

<span class="hljs-attr">t</span> = <span class="hljs-number">0</span>;
<span class="hljs-attr">count</span> = <span class="hljs-number">0</span>;

while (t &lt; tmax)
[fx, fy, fz, en] = force(npart, x, y, z, rc, Lx, Ly, Lz, ecut);
[temperature, etot, xm, ym, zm, x, y, z, KE, PE] = integrate_eqn(npart, Lx, Ly, Lz, dt, x, y, z, xm, ym, zm, fx, fy, fz, en, temp);

    mfprintf(fd, <span class="hljs-string">"%d\n\n"</span>, npart);
    for <span class="hljs-attr">i</span> = <span class="hljs-number">1</span>:npart

// x(i) = x(i) - Lx*round(x(i)/Lx);
// y(i) = y(i) - Ly*round(y(i)/Ly);
// z(i) = z(i) - Lz\*round(z(i)/Lz);
mfprintf(fd, <span class="hljs-string">"Ar %f %f %f\n"</span>, x(i), y(i), z(i));
end

    // Log timestep, KE, PE, <span class="hljs-literal">and</span> Total Energy to file
    mfprintf(energy_file, <span class="hljs-string">"%f\t%f\t%f\t%f\n"</span>, t, KE, PE, etot);

    <span class="hljs-attr">t</span> = t + dt;
    <span class="hljs-attr">count</span> = count + <span class="hljs-number">1</span>;
    disp(count);

end

mfprintf(fd, 'END');
mclose(fd);
mclose(energy_file);

</code></pre><ul>
<li>Initialization:<ul>
<li>Calls <code>initialization</code> to set initial positions (x, y, z), previous positions (<code>xm, ym, zm</code>), and velocities (<code>vx, vy, vz</code>).</li>
</ul>
</li>
<li>Time Integration Loop (<code>while t &lt; tmax</code>):<ul>
<li><em>Force calculation</em>: Computes forces between particles using <code>force</code>, based on the Lennard-Jones potential and periodic boundary conditions.</li>
<li><em>Integrate equations of motion</em>: Updates positions and velocities with <code>integrate_eqn</code> using the Velocity-Verlet algorithm.</li>
<li><em>Output trajectory</em>: Writes current particle positions to <code>traj_100.xyz</code> at every step.</li>
<li><em>Output energies</em>: Writes timestep, kinetic energy (KE), potential energy (PE), and total energy to <code>energy_log.txt</code> file.</li>
<li><em>Time update</em>: Increments simulation time <code>t</code> and step counter <code>count</code>.</li>
</ul>
</li>
<li>End of Simulation:<ul>
<li>Writes <code>END</code> to the trajectory file and closes all files.</li>
</ul>
</li>
</ul>
<hr>
<h1 id="result">Result</h1>
<p>Thus, the modelling and simulation of a simple gaseous system was created and studied using Scilab and VMD.</p>
